"""
Pydantic models for API responses
"""

from pydantic import BaseModel, Field
from typing import Any
from datetime import datetime


class TrackMetadata(BaseModel):
    """Metadata for a prediction track."""
    name: str
    strand: str
    ontology_curie: str | None = None
    assay: str | None = None


class TrackData(BaseModel):
    """Prediction track data."""
    values: list[list[float]] = Field(
        description="2D array [positions, tracks]"
    )
    metadata: list[TrackMetadata]
    resolution: int = 1
    interval: dict | None = None


class GeneScore(BaseModel):
    """Score for a single gene."""
    gene_id: str
    gene_name: str
    strand: str
    raw_score: float
    quantile_score: float
    tissue: str
    interpretation: str = ""


class VariantSummary(BaseModel):
    """Summary of variant effect."""
    variant: str
    impact_level: str = Field(
        description="HIGH, MODERATE, LOW, or MODIFIER"
    )
    affected_genes: list[str]
    top_effect: str
    confidence: float = Field(ge=0, le=1)


class PredictionResult(BaseModel):
    """Result of a prediction."""
    metadata: dict = Field(
        default_factory=lambda: {
            "tool": "AlphaGenome Explorer",
            "version": "1.0.0"
        }
    )
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    request_params: dict
    summary: VariantSummary | None = None
    scores: list[GeneScore] = []
    tracks: dict[str, TrackData] = {}


class VariantPredictResponse(BaseModel):
    """Response for variant prediction."""
    success: bool = True
    data: PredictionResult | None = None
    error: str | None = None

    # Export-ready formats
    export: dict = Field(
        default_factory=dict,
        description="Pre-formatted export data"
    )


class IntervalPredictResponse(BaseModel):
    """Response for interval prediction."""
    success: bool = True
    data: dict | None = None
    error: str | None = None
    export: dict = Field(default_factory=dict)


class ScoreResponse(BaseModel):
    """Response for variant scoring."""
    success: bool = True
    variant: str
    scores: list[GeneScore] = []
    total_genes: int = 0
    total_tracks: int = 0
    error: str | None = None

    # Export formats
    export: dict = Field(default_factory=dict)


class ISMResponse(BaseModel):
    """Response for ISM analysis."""
    success: bool = True
    interval: dict
    ism_matrix: list[list[float]] | None = None
    top_positions: list[dict] = []
    error: str | None = None
    export: dict = Field(default_factory=dict)


class GeneInfo(BaseModel):
    """Gene information."""
    gene_id: str
    gene_symbol: str
    chromosome: str
    start: int
    end: int
    strand: str
    gene_type: str


class GeneSearchResponse(BaseModel):
    """Response for gene search."""
    success: bool = True
    query: str
    results: list[GeneInfo] = []
    total: int = 0


class OntologyTerm(BaseModel):
    """Ontology term."""
    code: str
    name: str
    category: str  # 'tissue', 'cell_type', 'cell_line'


class MetadataResponse(BaseModel):
    """Response for metadata endpoints."""
    tissues: list[OntologyTerm] = []
    cell_lines: list[OntologyTerm] = []
    output_types: list[dict] = []


class HealthResponse(BaseModel):
    """Health check response."""
    status: str = "healthy"
    version: str
    timestamp: datetime = Field(default_factory=datetime.utcnow)


class ErrorResponse(BaseModel):
    """Standard error response."""
    success: bool = False
    error: str
    error_code: str | None = None
    details: dict | None = None


# ============ Export Format Helpers ============

def format_as_markdown(result: PredictionResult) -> str:
    """Format result as Markdown for copy-paste."""
    md = f"""## AlphaGenome Analysis: {result.request_params.get('variant', 'N/A')}

**Generated:** {result.timestamp.strftime('%Y-%m-%d %H:%M UTC')}

### Summary
| Metric | Value |
|--------|-------|
"""
    if result.summary:
        md += f"| Impact | {result.summary.impact_level} |\n"
        md += f"| Affected Genes | {', '.join(result.summary.affected_genes)} |\n"
        md += f"| Top Effect | {result.summary.top_effect} |\n"

    if result.scores:
        md += "\n### Gene Scores\n"
        md += "| Gene | Tissue | Score | Quantile | Interpretation |\n"
        md += "|------|--------|-------|----------|----------------|\n"
        for score in result.scores[:10]:  # Top 10
            md += f"| {score.gene_name} | {score.tissue} | {score.raw_score:.4f} | {score.quantile_score:.2f} | {score.interpretation} |\n"

    md += "\n---\n*Generated by [AlphaGenome Explorer](https://github.com/your-repo)*"
    return md


def format_as_csv(scores: list[GeneScore]) -> str:
    """Format scores as CSV."""
    lines = ["gene_id,gene_name,strand,tissue,raw_score,quantile_score,interpretation"]
    for s in scores:
        lines.append(
            f"{s.gene_id},{s.gene_name},{s.strand},{s.tissue},"
            f"{s.raw_score},{s.quantile_score},{s.interpretation}"
        )
    return "\n".join(lines)


def format_as_tsv(scores: list[GeneScore]) -> str:
    """Format scores as TSV."""
    lines = ["gene_id\tgene_name\tstrand\ttissue\traw_score\tquantile_score\tinterpretation"]
    for s in scores:
        lines.append(
            f"{s.gene_id}\t{s.gene_name}\t{s.strand}\t{s.tissue}\t"
            f"{s.raw_score}\t{s.quantile_score}\t{s.interpretation}"
        )
    return "\n".join(lines)
